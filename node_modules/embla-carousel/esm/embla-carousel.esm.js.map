{"version":3,"file":"embla-carousel.esm.js","sources":["../src/components/utils.ts","../src/components/Alignment.ts","../src/components/EventStore.ts","../src/components/Animations.ts","../src/components/Axis.ts","../src/components/Limit.ts","../src/components/Counter.ts","../src/components/DragHandler.ts","../src/components/DragTracker.ts","../src/components/PercentOfView.ts","../src/components/ResizeHandler.ts","../src/components/ScrollAnimator.ts","../src/components/ScrollBody.ts","../src/components/ScrollBounds.ts","../src/components/ScrollContain.ts","../src/components/ScrollLimit.ts","../src/components/ScrollLooper.ts","../src/components/ScrollProgress.ts","../src/components/ScrollSnaps.ts","../src/components/ScrollSnapList.ts","../src/components/ScrollTarget.ts","../src/components/ScrollTo.ts","../src/components/SlideFocus.ts","../src/components/NumberStore.ts","../src/components/SlideLooper.ts","../src/components/SlidesHandler.ts","../src/components/SlidesInView.ts","../src/components/SlideSizes.ts","../src/components/SlidesToScroll.ts","../src/components/Translate.ts","../src/components/ScrollOptimizer.ts","../src/components/Engine.ts","../src/components/EventHandler.ts","../src/components/Options.ts","../src/components/NodeHandler.ts","../src/components/OptionsHandler.ts","../src/components/PluginsHandler.ts","../src/components/SsrHandler.ts","../src/components/EmblaCarousel.ts"],"sourcesContent":["import { PointerEventType } from './DragTracker'\nimport { NumberStoreType } from './NumberStore'\n\nexport type WindowType = Window & typeof globalThis\n\nexport type NumberStoreInputType = NumberStoreType | number\n\nexport function mapStoreToNumber<ReturnType>(\n  callback: (input: number) => ReturnType\n): (input: NumberStoreInputType) => ReturnType {\n  return (input: NumberStoreInputType): ReturnType => {\n    return callback(isNumber(input) ? input : input.get())\n  }\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isString(subject: unknown): subject is string {\n  return typeof subject === 'string'\n}\n\nexport function isBoolean(subject: unknown): subject is boolean {\n  return typeof subject === 'boolean'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function mathAbs(input: number): number {\n  return Math.abs(input)\n}\n\nexport function mathSign(input: number): number {\n  return Math.sign(input)\n}\n\nexport function deltaAbs(inputB: number, inputA: number): number {\n  return mathAbs(inputB - inputA)\n}\n\nexport function factorAbs(inputB: number, inputA: number): number {\n  if (inputB === 0 || inputA === 0) return 0\n  if (mathAbs(inputB) <= mathAbs(inputA)) return 0\n  const diff = deltaAbs(mathAbs(inputB), mathAbs(inputA))\n  return mathAbs(diff / inputB)\n}\n\nexport function roundToTwoDecimals(input: number): number {\n  return Math.round(input * 100) / 100\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function arrayIsLastIndex<Type>(array: Type[], index: number): boolean {\n  return index === arrayLastIndex(array)\n}\n\nexport function arrayFromRange(end: number, start: number = 0): number[] {\n  return Array.from(Array(end - start + 1), (_, index) => start + index)\n}\n\nexport function objectKeys<Type extends object>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function isMouseEvent(\n  evt: PointerEventType,\n  ownerWindow: WindowType\n): evt is MouseEvent {\n  return (\n    typeof ownerWindow.MouseEvent !== 'undefined' &&\n    evt instanceof ownerWindow.MouseEvent\n  )\n}\n","import { isString } from './utils'\n\nexport type AlignmentOptionType =\n  | 'start'\n  | 'center'\n  | 'end'\n  | ((viewSize: number, snapSize: number, index: number) => number)\n\nexport type AlignmentType = {\n  measure: (input: number, index: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(input: number): number {\n    return end(input) / 2\n  }\n\n  function end(input: number): number {\n    return viewSize - input\n  }\n\n  function measure(input: number, index: number): number {\n    if (isString(align)) return predefined[align](input)\n    return align(viewSize, input, index)\n  }\n\n  const self: AlignmentType = {\n    measure\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType\n  ) => EventStoreType\n  clear: () => void\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true }\n  ): EventStoreType {\n    let removeListener: EventRemoverType\n\n    if ('addEventListener' in node) {\n      node.addEventListener(type, handler, options)\n      removeListener = () => node.removeEventListener(type, handler, options)\n    } else {\n      const legacyMediaQueryList = <MediaQueryList>node\n      legacyMediaQueryList.addListener(handler)\n      removeListener = () => legacyMediaQueryList.removeListener(handler)\n    }\n\n    listeners.push(removeListener)\n    return self\n  }\n\n  function clear(): void {\n    listeners = listeners.filter((remove) => remove())\n  }\n\n  const self: EventStoreType = {\n    add,\n    clear\n  }\n  return self\n}\n","import { EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { WindowType } from './utils'\n\nexport type AnimationsUpdateType = (engine: EngineType) => void\nexport type AnimationsRenderType = (engine: EngineType, alpha: number) => void\n\nexport type AnimationsType = {\n  init: (ownerWindow: WindowType) => void\n  destroy: () => void\n  start: () => void\n  stop: () => void\n  update: () => void\n  render: (alpha: number) => void\n}\n\nexport function Animations(\n  update: () => void,\n  render: (alpha: number) => void\n): AnimationsType {\n  const documentVisibleHandler = EventStore()\n  const fixedTimeStep = 1000 / 60\n\n  let windowInstance: WindowType\n  let lastTimeStamp: number | null = null\n  let accumulatedTime = 0\n  let animationId = 0\n\n  function init(ownerWindow: WindowType): void {\n    const ownerDocument = ownerWindow.document\n    windowInstance = ownerWindow\n\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.hidden) reset()\n    })\n  }\n\n  function destroy(): void {\n    stop()\n    documentVisibleHandler.clear()\n  }\n\n  function animate(timeStamp: DOMHighResTimeStamp): void {\n    if (!animationId) return\n    if (!lastTimeStamp) {\n      lastTimeStamp = timeStamp\n      update()\n      update()\n    }\n\n    const timeElapsed = timeStamp - lastTimeStamp\n    lastTimeStamp = timeStamp\n    accumulatedTime += timeElapsed\n\n    while (accumulatedTime >= fixedTimeStep) {\n      update()\n      accumulatedTime -= fixedTimeStep\n    }\n\n    const alpha = accumulatedTime / fixedTimeStep\n    render(alpha)\n\n    if (animationId) {\n      animationId = windowInstance.requestAnimationFrame(animate)\n    }\n  }\n\n  function start(): void {\n    if (animationId) return\n    animationId = windowInstance.requestAnimationFrame(animate)\n  }\n\n  function stop(): void {\n    if (!animationId) return\n    windowInstance.cancelAnimationFrame(animationId)\n    lastTimeStamp = null\n    accumulatedTime = 0\n    animationId = 0\n  }\n\n  function reset(): void {\n    lastTimeStamp = null\n    accumulatedTime = 0\n  }\n\n  const self: AnimationsType = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  }\n  return self\n}\n","import { NodeRectType } from './NodeHandler'\nimport { NumberStoreInputType, mapStoreToNumber } from './utils'\n\nexport type AxisOptionType = 'x' | 'y'\nexport type AxisDirectionOptionType = 'ltr' | 'rtl'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  nativeScroll: 'scrollLeft' | 'scrollTop'\n  getSize: (nodeRect: NodeRectType) => number\n  direction: (input: NumberStoreInputType) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: AxisDirectionOptionType\n): AxisType {\n  const isRightToLeft = contentDirection === 'rtl'\n  const isVertical = axis === 'y'\n  const scroll = isVertical ? 'y' : 'x'\n  const cross = isVertical ? 'x' : 'y'\n  const sign = !isVertical && isRightToLeft ? -1 : 1\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n  const nativeScroll = isVertical ? 'scrollTop' : 'scrollLeft'\n\n  function getSize(nodeRect: NodeRectType): number {\n    const { height, width } = nodeRect\n    return isVertical ? height : width\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (isVertical) return 'top'\n    return isRightToLeft ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (isVertical) return 'bottom'\n    return isRightToLeft ? 'left' : 'right'\n  }\n\n  function direction(input: number): number {\n    return input * sign\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    nativeScroll,\n    getSize,\n    direction: mapStoreToNumber(direction)\n  }\n  return self\n}\n","import { mathAbs, NumberStoreInputType, mapStoreToNumber } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  clamp: (input: NumberStoreInputType) => number\n  pastAnyBound: (input: NumberStoreInputType) => boolean\n  pastMaxBound: (input: NumberStoreInputType) => boolean\n  pastMinBound: (input: NumberStoreInputType) => boolean\n  removeOffset: (input: NumberStoreInputType) => number\n}\n\nexport function Limit(min: number = 0, max: number = 0): LimitType {\n  const length = mathAbs(min - max)\n\n  function pastMinBound(input: number): boolean {\n    return input < min\n  }\n\n  function pastMaxBound(input: number): boolean {\n    return input > max\n  }\n\n  function pastAnyBound(input: number): boolean {\n    return pastMinBound(input) || pastMaxBound(input)\n  }\n\n  function clamp(input: number): number {\n    if (!pastAnyBound(input)) return input\n    return pastMinBound(input) ? min : max\n  }\n\n  function removeOffset(input: number): number {\n    if (!length) return input\n    return input - length * Math.ceil((input - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    clamp: mapStoreToNumber(clamp),\n    pastAnyBound: mapStoreToNumber(pastAnyBound),\n    pastMaxBound: mapStoreToNumber(pastMaxBound),\n    pastMinBound: mapStoreToNumber(pastMinBound),\n    removeOffset: mapStoreToNumber(removeOffset)\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (input: number) => CounterType\n  add: (input: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean\n): CounterType {\n  const { clamp } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = normalize(start)\n\n  function normalize(input: number): number {\n    return !loop ? clamp(input) : mathAbs((loopEnd + input) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(input: number): CounterType {\n    counter = normalize(input)\n    return self\n  }\n\n  function add(input: number): CounterType {\n    return clone().set(get() + input)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    get,\n    set,\n    add,\n    clone\n  }\n  return self\n}\n","import { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { NumberStoreType } from './NumberStore'\nimport { PercentOfViewType } from './PercentOfView'\nimport { Limit } from './Limit'\nimport {\n  deltaAbs,\n  factorAbs,\n  isMouseEvent,\n  mathAbs,\n  mathSign,\n  WindowType\n} from './utils'\n\nexport type DragHandlerType = {\n  init: (ownerWindow: WindowType) => void\n  destroy: () => void\n  pointerDown: () => boolean\n}\n\nexport function DragHandler(\n  active: boolean,\n  axis: AxisType,\n  rootNode: HTMLElement,\n  target: NumberStoreType,\n  dragTracker: DragTrackerType,\n  location: NumberStoreType,\n  animation: AnimationsType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  indexCurrent: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  dragFree: boolean,\n  dragThreshold: number,\n  skipSnaps: boolean,\n  baseFriction: number\n): DragHandlerType {\n  const { cross: crossAxis, direction } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const initEvents = EventStore()\n  const mouseEvents = EventStore()\n  const goToNextThreshold = Limit(50, 225).clamp(percentOfView.measure(20))\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseDuration = dragFree ? 43 : 25\n\n  let documentInstance: Document\n  let windowInstance: WindowType\n  let isMoving = false\n  let startScroll = 0\n  let startCross = 0\n  let runTouchEvents = false\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function init(ownerWindow: WindowType): void {\n    if (!active) return\n\n    documentInstance = ownerWindow.document\n    windowInstance = ownerWindow\n\n    dragTracker.init(ownerWindow)\n\n    const node = rootNode\n    initEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', (e) => runTouchEvents && move(e), nonPassiveEvent)\n      .add(node, 'touchend', (e) => runTouchEvents && up(e))\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function destroy(): void {\n    initEvents.clear()\n    mouseEvents.clear()\n    runTouchEvents = false\n  }\n\n  function addMouseEvents(): void {\n    const node = isMouse ? documentInstance : rootNode\n\n    mouseEvents\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const nodeName = node.nodeName || ''\n    return focusNodes.includes(nodeName)\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function indexChanged(): boolean {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    return currentLocation.index !== indexCurrent.get()\n  }\n\n  function baseForce(force: number): number {\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function allowedForce(force: number): number {\n    const next = indexCurrent.add(mathSign(force) * -1)\n\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce(force)\n    if (skipSnaps && indexChanged()) return baseForce(force) * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    const event = eventHandler.createEvent('pointerdown', evt)\n    const preventDefault = !event.emit()\n    if (preventDefault) return\n\n    const isMouseEvt = isMouseEvent(evt, windowInstance)\n    const isNotLeftButton = isMouseEvt && evt.button !== 0\n\n    isMouse = isMouseEvt\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving\n    isMoving = deltaAbs(target.get(), location.get()) >= 2\n\n    if (isNotLeftButton) return\n    if (isFocusNode(evt.target as Element)) return\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    scrollBody.useFriction(0).useDuration(0)\n    target.set(location)\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n\n    addMouseEvents()\n    runTouchEvents = true\n  }\n\n  function move(evt: PointerEventType): void {\n    const event = eventHandler.createEvent('pointermove', evt)\n    const preventDefault = !event.emit()\n    if (preventDefault) return up(evt)\n\n    const isTouchEvt = !isMouseEvent(evt, windowInstance)\n    const isPinching = isTouchEvt && evt.touches.length >= 2\n    if (isPinching) return up(evt)\n\n    const lastScroll = dragTracker.readPoint(evt)\n    const lastCross = dragTracker.readPoint(evt, crossAxis)\n    const diffScroll = deltaAbs(lastScroll, startScroll)\n    const diffCross = deltaAbs(lastCross, startCross)\n\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (diffScroll > dragThreshold) preventClick = true\n\n    scrollBody.useFriction(0.3).useDuration(0.75)\n    animation.start()\n    target.add(direction(diff))\n\n    if (evt.cancelable) evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const event = eventHandler.createEvent('pointerup', evt)\n\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction(rawForce))\n    const forceFactor = factorAbs(rawForce, force)\n    const duration = baseDuration - 10 * forceFactor\n    const friction = baseFriction + forceFactor / 50\n\n    preventScroll = false\n    pointerIsDown = false\n    runTouchEvents = false\n    isMouse = false\n    mouseEvents.clear()\n\n    scrollBody.useDuration(duration).useFriction(friction)\n    scrollTo.distance(force, !dragFree)\n    event.emit()\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n      preventClick = false\n    }\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    init,\n    destroy,\n    pointerDown\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { isMouseEvent, mathAbs, WindowType } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  init: (ownerWindow: WindowType) => void\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let windowInstance: WindowType\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function init(ownerWindow: WindowType): void {\n    windowInstance = ownerWindow\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isMouseEvent(evt, windowInstance) ? evt : evt.touches[0])[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    init,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (input: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(input: number): number {\n    return viewSize * (input / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { EventHandlerType } from './EventHandler'\nimport { NodeHandlerType } from './NodeHandler'\nimport { mathAbs, WindowType } from './utils'\n\nexport type ResizeHandlerType = {\n  init: (ownerWindow: WindowType) => void\n  destroy: () => void\n}\n\nexport function ResizeHandler(\n  active: boolean,\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  slides: HTMLElement[],\n  axis: AxisType,\n  nodeHandler: NodeHandlerType\n): ResizeHandlerType {\n  const observeNodes = [container, ...slides]\n  let resizeObserver: ResizeObserver\n  let containerSize: number\n  let slideSizes: number[] = []\n  let destroyed = false\n\n  function readSize(node: HTMLElement): number {\n    return axis.getSize(nodeHandler.getRect(node))\n  }\n\n  function init(ownerWindow: WindowType): void {\n    if (!active) return\n\n    containerSize = readSize(container)\n    slideSizes = slides.map(readSize)\n\n    resizeObserver = new ownerWindow.ResizeObserver(onResize)\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach((node) => resizeObserver.observe(node))\n    })\n  }\n\n  function destroy(): void {\n    destroyed = true\n    if (resizeObserver) resizeObserver.disconnect()\n  }\n\n  function onResize(entries: ResizeObserverEntry[]): void {\n    const event = eventHandler.createEvent('resize', entries)\n    const preventDefault = !event.emit()\n    if (preventDefault) return\n\n    for (const entry of entries) {\n      if (destroyed) return\n\n      const isContainer = entry.target === container\n      const slideIndex = slides.indexOf(<HTMLElement>entry.target)\n      const lastSize = isContainer ? containerSize : slideSizes[slideIndex]\n\n      const newSize = readSize(isContainer ? container : slides[slideIndex])\n      const diffSize = mathAbs(newSize - lastSize)\n\n      if (diffSize >= 0.5) {\n        event.api.reInit()\n        break\n      }\n    }\n  }\n\n  const self: ResizeHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { AnimationsRenderType, AnimationsUpdateType } from './Animations'\nimport { EngineType } from './Engine'\n\nexport type ScrollEventType = { isDragging: boolean }\n\nexport type ScrollAnimatorType = {\n  update: AnimationsUpdateType\n  render: AnimationsRenderType\n}\n\nexport function ScrollAnimator(): ScrollAnimatorType {\n  function update(engine: EngineType) {\n    const {\n      dragHandler,\n      scrollBody,\n      scrollBounds,\n      options: { loop }\n    } = engine\n\n    if (!loop) scrollBounds.constrain(dragHandler.pointerDown())\n    scrollBody.seek()\n  }\n\n  function render(engine: EngineType, alpha: number) {\n    const {\n      scrollBody,\n      translate,\n      location,\n      offsetLocation,\n      previousLocation,\n      scrollLooper,\n      slideLooper,\n      dragHandler,\n      animation,\n      eventHandler,\n      scrollBounds,\n      scrollOptimizer,\n      options: { loop }\n    } = engine\n\n    const isIdle = scrollBody.settled()\n    const isWithinBounds = !scrollBounds.shouldConstrain()\n    const isPointerDown = dragHandler.pointerDown()\n\n    const canSettle = loop || isWithinBounds\n    const isIdleAndCanSettle = isIdle && canSettle\n\n    const isScrolling = !isIdleAndCanSettle\n    const isDragging = isScrolling && isPointerDown\n    const isSettled = isIdleAndCanSettle && !isPointerDown\n\n    if (isSettled) {\n      scrollOptimizer.optimize(isSettled)\n      animation.stop()\n    }\n\n    const interpolatedLocation =\n      location.get() * alpha + previousLocation.get() * (1 - alpha)\n\n    offsetLocation.set(interpolatedLocation)\n\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction())\n      slideLooper.loop()\n    }\n\n    translate.to(offsetLocation)\n    scrollOptimizer.optimize()\n\n    if (isSettled) {\n      const event = eventHandler.createEvent('settle', null)\n      event.emit()\n    }\n    if (isScrolling) {\n      const event = eventHandler.createEvent('scroll', { isDragging })\n      event.emit()\n    }\n  }\n\n  const self: ScrollAnimatorType = {\n    update,\n    render\n  }\n  return self\n}\n","import { mathSign, mathAbs } from './utils'\nimport { NumberStoreType } from './NumberStore'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  duration: () => number\n  velocity: () => number\n  seek: () => ScrollBodyType\n  settled: () => boolean\n  useBaseFriction: () => ScrollBodyType\n  useBaseDuration: () => ScrollBodyType\n  useFriction: (input: number) => ScrollBodyType\n  useDuration: (input: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: NumberStoreType,\n  offsetLocation: NumberStoreType,\n  previousLocation: NumberStoreType,\n  target: NumberStoreType,\n  baseDuration: number,\n  baseFriction: number\n): ScrollBodyType {\n  let scrollVelocity = 0\n  let scrollDirection = 0\n  let scrollDuration = baseDuration\n  let scrollFriction = baseFriction\n  let rawLocation = location.get()\n  let rawLocationPrevious = 0\n\n  function seek(): ScrollBodyType {\n    const displacement = target.minus(location)\n    const isInstant = !scrollDuration\n    let scrollDistance = 0\n\n    if (isInstant) {\n      scrollVelocity = 0\n      previousLocation.set(target)\n      location.set(target)\n\n      scrollDistance = displacement\n    } else {\n      previousLocation.set(location)\n\n      scrollVelocity += displacement / scrollDuration\n      scrollVelocity *= scrollFriction\n      rawLocation += scrollVelocity\n      location.add(scrollVelocity)\n\n      scrollDistance = rawLocation - rawLocationPrevious\n    }\n\n    scrollDirection = mathSign(scrollDistance)\n    rawLocationPrevious = rawLocation\n    return self\n  }\n\n  function settled(): boolean {\n    const displacement = target.minus(offsetLocation)\n    return mathAbs(displacement) < 0.001\n  }\n\n  function duration(): number {\n    return scrollDuration\n  }\n\n  function direction(): number {\n    return scrollDirection\n  }\n\n  function velocity(): number {\n    return scrollVelocity\n  }\n\n  function useBaseDuration(): ScrollBodyType {\n    return useDuration(baseDuration)\n  }\n\n  function useBaseFriction(): ScrollBodyType {\n    return useFriction(baseFriction)\n  }\n\n  function useDuration(input: number): ScrollBodyType {\n    scrollDuration = input\n    return self\n  }\n\n  function useFriction(input: number): ScrollBodyType {\n    scrollFriction = input\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { NumberStoreType } from './NumberStore'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  shouldConstrain: () => boolean\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: NumberStoreType,\n  target: NumberStoreType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType\n): ScrollBoundsType {\n  const { pastAnyBound, pastMinBound, clamp } = limit\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const frictionLimit = Limit(0.1, 0.99)\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!pastAnyBound(target)) return false\n    if (!pastAnyBound(location)) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = pastMinBound(location) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const displacement = target.minus(location)\n    const friction = frictionLimit.clamp(diffToEdge / edgeOffsetTolerance)\n\n    target.subtract(displacement * friction)\n\n    if (!pointerDown && mathAbs(displacement) < pullBackThreshold) {\n      target.set(clamp(target))\n      scrollBody.useDuration(25).useBaseFriction()\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayIsLastIndex, arrayLast, deltaAbs } from './utils'\n\nexport type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n  scrollContainLimit: LimitType\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n  pixelTolerance: number\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, 0)\n  const snapsBounded = getSnapsBounded()\n  const scrollContainLimit = getScrollContainLimit()\n  const snapsContained = getSnapsContained()\n\n  function usePixelTolerance(bound: number, snap: number): boolean {\n    return pixelTolerance ? deltaAbs(bound, snap) <= 1 : false\n  }\n\n  function getScrollContainLimit(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function getSnapsBounded(): number[] {\n    return snapsAligned\n      .map((snapAligned, index) => {\n        const { min, max } = scrollBounds\n        const snap = scrollBounds.clamp(snapAligned)\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(snapsAligned, index)\n        if (isFirst) return max\n        if (isLast) return min\n        if (usePixelTolerance(min, snap)) return min\n        if (usePixelTolerance(max, snap)) return max\n        return snap\n      })\n      .map((scrollBound) => parseFloat(scrollBound.toFixed(3)))\n  }\n\n  function getSnapsContained(): number[] {\n    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = scrollContainLimit\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n    scrollContainLimit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean\n): ScrollLimitType {\n  const max = scrollSnaps[0]\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps)\n  const limit = Limit(min, max)\n\n  const self: ScrollLimitType = {\n    limit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { NumberStoreType } from './NumberStore'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: NumberStoreType,\n  loopEntities: NumberStoreType[]\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { pastMinBound, pastMaxBound } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return pastMaxBound(location)\n    if (direction === -1) return pastMinBound(location)\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    loopEntities.forEach((loopEntity) => loopEntity.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { NumberStoreInputType, mapStoreToNumber } from './utils'\n\nexport type ScrollProgressType = {\n  get: (input: NumberStoreInputType) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length } = limit\n\n  function get(input: number): number {\n    const currentLocation = input - max\n    return length ? currentLocation / -length : 0\n  }\n\n  const self: ScrollProgressType = {\n    get: mapStoreToNumber(get)\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { NodeRectType } from './NodeHandler'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slidesToScroll: SlidesToScrollType\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { ScrollProgressType } from './ScrollProgress'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport {\n  arrayFromRange,\n  arrayIsLastIndex,\n  arrayLast,\n  arrayLastIndex\n} from './utils'\n\ntype SnapBySlideType = { [key: number]: number }\n\nexport type ScrollSnapListType = {\n  slidesBySnap: number[][]\n  snapBySlide: SnapBySlideType\n  progressBySnap: number[]\n  length: number\n}\n\nexport function ScrollSnapList(\n  containSnaps: boolean,\n  containScroll: ScrollContainOptionType,\n  scrollSnaps: number[],\n  scrollContainLimit: LimitType,\n  slidesToScroll: SlidesToScrollType,\n  slideIndexes: number[],\n  scrollProgress: ScrollProgressType\n): ScrollSnapListType {\n  const { groupSlides } = slidesToScroll\n  const { min, max } = scrollContainLimit\n  const slidesBySnap = getSlidesBySnap()\n  const snapBySlide = getSnapsBySlide()\n  const progressBySnap = scrollSnaps.map(scrollProgress.get)\n  const length = scrollSnaps.length\n\n  function getSlidesBySnap(): number[][] {\n    const groupedSlideIndexes = groupSlides(slideIndexes)\n    const doNotContain = !containSnaps || containScroll === 'keepSnaps'\n\n    if (scrollSnaps.length === 1) return [slideIndexes]\n    if (doNotContain) return groupedSlideIndexes\n\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index\n      const isLast = arrayIsLastIndex(groups, index)\n\n      if (isFirst) {\n        const rangeEnd = arrayLast(group)\n        return arrayFromRange(rangeEnd)\n      }\n      if (isLast) {\n        const rangeEnd = arrayLastIndex(slideIndexes)\n        return arrayFromRange(rangeEnd, group[0])\n      }\n      return group\n    })\n  }\n\n  function getSnapsBySlide(): SnapBySlideType {\n    const snapBySlide: SnapBySlideType = {}\n\n    slidesBySnap.forEach((slideGroup, snapIndex) => {\n      slideGroup.forEach((slideIndex) => {\n        snapBySlide[slideIndex] = snapIndex\n      })\n    })\n    return snapBySlide\n  }\n\n  const self: ScrollSnapListType = {\n    slidesBySnap,\n    snapBySlide,\n    progressBySnap,\n    length\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { DirectionType } from './ScrollTo'\nimport { NumberStoreType } from './NumberStore'\nimport { arrayLast, mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: DirectionType) => TargetType\n  byDistance: (force: number, snapToClosest: boolean) => TargetType\n  shortcut: (target: number, direction: DirectionType) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: NumberStoreType\n): ScrollTargetType {\n  const { pastAnyBound, removeOffset, clamp } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function getClosestSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : clamp(target)\n    const { index } = scrollSnaps.reduce(\n      (result, snap, snapIndex) => {\n        const displacementAbs = mathAbs(shortcut(snap - distance, 0))\n        if (displacementAbs >= result.smallestDisplacement) return result\n        return { smallestDisplacement: displacementAbs, index: snapIndex }\n      },\n      { smallestDisplacement: Infinity, index: 0 }\n    )\n\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: DirectionType): number {\n    if (!loop) return target\n\n    const targets = [target, target + contentSize, target - contentSize]\n    if (!direction) return minDistance(targets)\n\n    const validTargets = targets.filter((t) => mathSign(t) === direction)\n    if (validTargets.length) return minDistance(validTargets)\n    return arrayLast(targets) - contentSize\n  }\n\n  function byIndex(index: number, direction: DirectionType): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snapToClosest: boolean): TargetType {\n    const target = targetVector.plus(distance)\n    const { index, distance: targetSnapDistance } = getClosestSnap(target)\n    const isPastAnyBound = !loop && pastAnyBound(target)\n\n    if (!snapToClosest || isPastAnyBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut\n  }\n  return self\n}\n","import { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { NumberStoreType } from './NumberStore'\nimport { isNumber } from './utils'\n\nexport type DirectionType = 0 | 1 | -1\nexport type ScrollToDirectionType = 'forward' | 'backward' | DirectionType\nexport type SelectEventType = { targetSnap: number; sourceSnap: number }\n\nexport type ScrollToType = {\n  distance: (input: number, snapToClosest: boolean) => void\n  index: (input: number, direction?: ScrollToDirectionType) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationsType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  targetVector: NumberStoreType,\n  eventHandler: EventHandlerType\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const { index: targetSnap, distance: targetDisplacement } = target\n    const sourceSnap = indexCurrent.get()\n    const hasIndexChanged = targetSnap !== sourceSnap\n\n    if (targetDisplacement) {\n      targetVector.add(targetDisplacement)\n\n      if (scrollBody.duration()) {\n        animation.start()\n      } else {\n        animation.update()\n        animation.render(1)\n        animation.update()\n      }\n    }\n\n    if (hasIndexChanged) {\n      indexPrevious.set(sourceSnap)\n      indexCurrent.set(targetSnap)\n\n      const event = eventHandler.createEvent('select', {\n        targetSnap,\n        sourceSnap\n      })\n      event.emit()\n    }\n  }\n\n  function distance(input: number, snapToClosest: boolean): void {\n    const target = scrollTarget.byDistance(input, snapToClosest)\n    scrollTo(target)\n  }\n\n  function index(input: number, direction?: ScrollToDirectionType): void {\n    const targetIndex = indexCurrent.clone().set(input).get()\n    const target = scrollTarget.byIndex(targetIndex, getDirection(direction))\n    scrollTo(target)\n  }\n\n  function getDirection(direction?: ScrollToDirectionType): DirectionType {\n    if (!direction) return 0\n    if (isNumber(direction)) return direction\n    return direction === 'forward' ? -1 : 1\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStoreType } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollToType } from './ScrollTo'\nimport { ScrollSnapListType } from './ScrollSnapList'\nimport { isNumber, WindowType } from './utils'\n\nexport type SlideFocusType = {\n  init: (ownerWindow: WindowType) => void\n}\n\nexport function SlideFocus(\n  axis: AxisType,\n  active: boolean,\n  root: HTMLElement,\n  slides: HTMLElement[],\n  scrollSnapList: ScrollSnapListType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  eventStore: EventStoreType,\n  eventHandler: EventHandlerType\n): SlideFocusType {\n  const focusListenerOptions = { passive: true, capture: true }\n  let lastTabPressTime = 0\n\n  function init(ownerWindow: WindowType): void {\n    if (!active) return\n\n    eventStore.add(ownerWindow.document, 'keydown', onKeyDown, false)\n\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(\n        slide,\n        'focus',\n        (evt: FocusEvent) => onFocus(evt, slideIndex),\n        focusListenerOptions\n      )\n    })\n  }\n\n  function onFocus(evt: FocusEvent, slideIndex: number): void {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastTabPressTime\n\n    if (diffTime > 10) return\n\n    const event = eventHandler.createEvent('slidefocus', evt)\n    const preventDefault = !event.emit()\n    if (preventDefault) return\n\n    root[axis.nativeScroll] = 0\n\n    const snapIndex = scrollSnapList.snapBySlide[slideIndex]\n\n    if (!isNumber(snapIndex)) return\n\n    scrollBody.useDuration(0)\n    scrollTo.index(snapIndex, 0)\n  }\n\n  function onKeyDown(event: KeyboardEvent): void {\n    if (event.code === 'Tab') lastTabPressTime = new Date().getTime()\n  }\n\n  const self: SlideFocusType = {\n    init\n  }\n  return self\n}\n","import { NumberStoreInputType, mapStoreToNumber } from './utils'\n\nexport type NumberStoreType = {\n  get: () => number\n  set: (input: NumberStoreInputType) => void\n  add: (input: NumberStoreInputType) => void\n  subtract: (input: NumberStoreInputType) => void\n  plus: (input: NumberStoreInputType) => number\n  minus: (input: NumberStoreInputType) => number\n}\n\nexport function NumberStore(initialValue: number): NumberStoreType {\n  let value = initialValue || 0\n\n  function get(): number {\n    return value\n  }\n\n  function set(input: number): void {\n    value = input\n  }\n\n  function add(input: number): void {\n    value += input\n  }\n\n  function subtract(input: number): void {\n    add(-input)\n  }\n\n  function plus(input: number): number {\n    return value + input\n  }\n\n  function minus(input: number): number {\n    return plus(-input)\n  }\n\n  const self: NumberStoreType = {\n    get,\n    set: mapStoreToNumber(set),\n    add: mapStoreToNumber(add),\n    subtract: mapStoreToNumber(subtract),\n    plus: mapStoreToNumber(plus),\n    minus: mapStoreToNumber(minus)\n  }\n  return self\n}\n","import { arrayKeys } from './utils'\nimport { NumberStore, NumberStoreType } from './NumberStore'\nimport { TranslateType } from './Translate'\n\ntype SlideBoundType = {\n  start: number\n  end: number\n}\n\ntype LoopPointType = {\n  loopPoint: number\n  index: number\n  translate: TranslateType\n  slideLocation: NumberStoreType\n  target: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  slideSizesWithGaps: number[],\n  snaps: number[],\n  scrollSnaps: number[],\n  location: NumberStoreType,\n  slideTranslates: TranslateType[]\n): SlideLooperType {\n  const roundingSafety = 0.5\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function getRemainingGapAfterSlides(indexes: number[], from: number): number {\n    return indexes.reduce((remainingGap: number, index) => {\n      return remainingGap - slideSizesWithGaps[index]\n    }, from)\n  }\n\n  function getSlidesThatFitGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((slidesThatFit: number[], index) => {\n      const remainingGap = getRemainingGapAfterSlides(slidesThatFit, gap)\n      return remainingGap > 0 ? [...slidesThatFit, index] : slidesThatFit\n    }, [])\n  }\n\n  function getSlideBounds(offset: number): SlideBoundType[] {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }))\n  }\n\n  function getLoopPoints(\n    indexes: number[],\n    offset: number,\n    isEndEdge: boolean\n  ): LoopPointType[] {\n    const slideBounds = getSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize\n      const altered = isEndEdge ? contentSize : 0\n      const boundEdge = isEndEdge ? 'end' : 'start'\n      const loopPoint = slideBounds[index][boundEdge]\n\n      return {\n        index,\n        loopPoint,\n        slideLocation: NumberStore(-1),\n        translate: slideTranslates[index],\n        target: () => (location.get() > loopPoint ? initial : altered)\n      }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0]\n    const indexes = getSlidesThatFitGap(descItems, gap)\n    return getLoopPoints(indexes, contentSize, false)\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = getSlidesThatFitGap(ascItems, gap)\n    return getLoopPoints(indexes, -contentSize, true)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return getRemainingGapAfterSlides(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, slideLocation } = loopPoint\n      const shiftLocation = target()\n      if (shiftLocation === slideLocation.get()) return\n      translate.to(shiftLocation)\n      slideLocation.set(shiftLocation)\n    })\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    loop,\n    loopPoints\n  }\n  return self\n}\n","import { EventHandlerType } from './EventHandler'\nimport { WindowType } from './utils'\n\nexport type SlidesHandlerType = {\n  init: (ownerWindow: WindowType) => void\n  destroy: () => void\n}\n\nexport function SlidesHandler(\n  active: boolean,\n  container: HTMLElement,\n  eventHandler: EventHandlerType\n): SlidesHandlerType {\n  let mutationObserver: MutationObserver\n  let destroyed = false\n\n  function init(ownerWindow: WindowType): void {\n    if (!active) return\n\n    mutationObserver = new ownerWindow.MutationObserver(onSlidesChange)\n\n    mutationObserver.observe(container, { childList: true })\n  }\n\n  function destroy(): void {\n    if (mutationObserver) mutationObserver.disconnect()\n    destroyed = true\n  }\n\n  function onSlidesChange(mutations: MutationRecord[]): void {\n    const event = eventHandler.createEvent('slideschanged', mutations)\n    const preventDefault = !event.emit()\n    if (preventDefault) return\n\n    for (const mutation of mutations) {\n      if (destroyed) return\n\n      if (mutation.type === 'childList') {\n        event.api.reInit()\n        break\n      }\n    }\n  }\n\n  const self: SlidesHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EventHandlerType } from './EventHandler'\nimport { WindowType } from './utils'\n\nexport type SlidesInViewThresholdOptionsType =\n  IntersectionObserverInit['threshold']\n\nexport type SlidesInViewMarginOptionsType =\n  IntersectionObserverInit['rootMargin']\n\nexport type SlidesInViewEventType = {\n  slidesInView: number[]\n  slidesLeftView: number[]\n  slidesEnterView: number[]\n}\n\nexport type SlidesInViewType = {\n  init: (ownerWindow: WindowType) => void\n  destroy: () => void\n  get: () => number[]\n}\n\nexport function SlidesInView(\n  container: HTMLElement,\n  slides: HTMLElement[],\n  eventHandler: EventHandlerType,\n  threshold: SlidesInViewThresholdOptionsType,\n  rootMargin: SlidesInViewMarginOptionsType\n): SlidesInViewType {\n  const slidesInView = new Set<number>()\n  let intersectionObserver: IntersectionObserver\n  let destroyed = false\n\n  function init(ownerWindow: WindowType): void {\n    intersectionObserver = new ownerWindow.IntersectionObserver(\n      onIntersection,\n      {\n        root: container.parentElement,\n        threshold,\n        rootMargin\n      }\n    )\n\n    slides.forEach((slide) => intersectionObserver.observe(slide))\n  }\n\n  function destroy(): void {\n    if (intersectionObserver) intersectionObserver.disconnect()\n    destroyed = true\n  }\n\n  function onIntersection(entries: IntersectionObserverEntry[]): void {\n    const slidesEnterView: number[] = []\n    const slidesLeftView: number[] = []\n\n    for (const entry of entries) {\n      if (destroyed) return\n      const index = slides.indexOf(<HTMLElement>entry.target)\n\n      if (entry.isIntersecting) {\n        slidesInView.add(index)\n        slidesEnterView.push(index)\n      } else {\n        slidesInView.delete(index)\n        slidesLeftView.push(index)\n      }\n    }\n\n    const event = eventHandler.createEvent('slidesinview', {\n      slidesInView: get(),\n      slidesLeftView,\n      slidesEnterView\n    })\n    event.emit()\n  }\n\n  function get(): number[] {\n    return [...slidesInView]\n  }\n\n  const self: SlidesInViewType = {\n    init,\n    destroy,\n    get\n  }\n\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeHandlerType } from './NodeHandler'\nimport { NodeRectType } from './NodeHandler'\nimport { arrayIsLastIndex, arrayLast, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n  startGap: number\n  endGap: number\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n  nodeHandler: NodeHandlerType\n): SlideSizesType {\n  const { ownerWindow } = nodeHandler\n  const { getSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap && ownerWindow\n  const startGap = getStartGap()\n  const endGap = getEndGap()\n  const slideSizes = slideRects.map(getSize)\n  const slideSizesWithGaps = getSlideSizesWithGaps()\n\n  function getStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function getEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = ownerWindow.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function getSlideSizesWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(rects, index)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeHandler'\nimport {\n  arrayKeys,\n  arrayLast,\n  arrayLastIndex,\n  isNumber,\n  mathAbs\n} from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  axis: AxisType,\n  viewSize: number,\n  slidesToScroll: SlidesToScrollOptionType,\n  loop: boolean,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  startGap: number,\n  endGap: number,\n  pixelTolerance: number\n): SlidesToScrollType {\n  const { startEdge, endEdge, direction } = axis\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    if (!array.length) return []\n\n    return arrayKeys(array)\n      .reduce((groups: number[], rectB, index) => {\n        const rectA = arrayLast(groups) || 0\n        const isFirst = rectA === 0\n        const isLast = rectB === arrayLastIndex(array)\n\n        const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge]\n        const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge]\n        const gapA = !loop && isFirst ? direction(startGap) : 0\n        const gapB = !loop && isLast ? direction(endGap) : 0\n        const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA))\n\n        if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB)\n        if (isLast) groups.push(array.length)\n        return groups\n      }, [])\n      .map((currentSize, index, groups) => {\n        const previousSize = Math.max(groups[index - 1] || 0)\n        return array.slice(previousSize, currentSize)\n      })\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport {\n  roundToTwoDecimals,\n  NumberStoreInputType,\n  mapStoreToNumber\n} from './utils'\n\nexport type TranslateType = {\n  set: (translate: string) => void\n  get: (input: NumberStoreInputType) => string\n  to: (input: NumberStoreInputType) => void\n  setIsScrolling: (active: boolean) => void\n  toggleActive: (active: boolean) => void\n  clear: () => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  node: HTMLElement,\n  unit: 'px' | '%' = 'px'\n): TranslateType {\n  const getTranslate = axis.scroll === 'x' ? x : y\n\n  let lastTranslate: string | null = null\n  let isScrolling = false\n  let disabled = false\n\n  function set(translate: string): void {\n    if (lastTranslate === translate) return\n    lastTranslate = translate\n    node.style.transform = translate\n  }\n\n  function x(input: number): string {\n    return `translate3d(${input}${unit},0px,0px)`\n  }\n\n  function y(input: number): string {\n    return `translate3d(0px,${input}${unit},0px)`\n  }\n\n  function setIsScrolling(active: boolean): void {\n    if (disabled) return\n    if (isScrolling === active) return\n\n    isScrolling = active\n    const transform = active ? getTranslate(0) : ''\n    set(transform)\n  }\n\n  function to(input: number): void {\n    if (disabled) return\n    if (!isScrolling) setIsScrolling(true)\n\n    const newTarget = roundToTwoDecimals(axis.direction(input))\n    set(getTranslate(newTarget))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    set('')\n    if (!node.getAttribute('style')) node.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    set,\n    clear,\n    to: mapStoreToNumber(to),\n    get: mapStoreToNumber(getTranslate),\n    toggleActive,\n    setIsScrolling\n  }\n  return self\n}\n","import { Counter, CounterType } from './Counter'\nimport { SlideLooperType } from './SlideLooper'\nimport { ScrollSnapListType } from './ScrollSnapList'\nimport { TranslateType } from './Translate'\nimport { arrayIsLastIndex } from './utils'\nimport { NumberStoreType } from './NumberStore'\nimport { EventHandlerType } from './EventHandler'\n\nexport type ScrollOptimizeEventType = {\n  slidesInView: number[]\n  slidesLeftView: number[]\n}\n\ntype SlideBoundType = {\n  start: number\n  end: number\n}\n\ntype SlideBoundMapType = {\n  [key: number]: SlideBoundType[]\n}\n\nexport type ScrollOptimizerType = {\n  optimize: (settle?: boolean) => void\n}\n\nexport function ScrollOptimizer(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  loop: boolean,\n  indexCurrent: CounterType,\n  scrollSnapList: ScrollSnapListType,\n  offsetlocation: NumberStoreType,\n  target: NumberStoreType,\n  slideTranslates: TranslateType[],\n  slideLooper: SlideLooperType,\n  eventHandler: EventHandlerType\n): ScrollOptimizerType {\n  const inViewThreshold = -200\n  const inViewOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const inViewBounds = createSlideBounds()\n  const slideIndexCounter = Counter(snaps.length - 1, 0, loop)\n\n  let previousTarget = target.get()\n  let slidesInView: number[] = getSlidesInViewRange()\n  let slidesInViewPrevious: number[] = slidesInView\n  let slidesLeftView: number[] = []\n\n  function filterNotIncluded(source: number[], exclusion: number[]): number[] {\n    const exclusionSet = new Set(exclusion)\n    return source.filter((item) => !exclusionSet.has(item))\n  }\n\n  function createSlideBound(index: number, snap: number): SlideBoundType[] {\n    return inViewOffsets.map((inViewOffset) => {\n      return {\n        start: snap - slideSizes[index] + inViewThreshold + inViewOffset,\n        end: snap + viewSize - inViewThreshold + inViewOffset\n      }\n    })\n  }\n\n  function createSlideBounds(): SlideBoundMapType {\n    return snaps.reduce((slideBounds, snap, index) => {\n      return {\n        ...slideBounds,\n        [index]: createSlideBound(index, snap)\n      }\n    }, {})\n  }\n\n  function getIsSlideInView(\n    rangeStart: number,\n    rangeEnd: number\n  ): (index: number) => boolean {\n    return (index: number): boolean => {\n      return inViewBounds[index].some(({ start, end }) => {\n        return start < rangeStart && end > rangeEnd\n      })\n    }\n  }\n\n  function collectSlidesInView(\n    inViewList: number[],\n    startIndex: number,\n    direction: 1 | -1,\n    isSlideInView: (index: number) => boolean\n  ): void {\n    const hasSlidesInView = inViewList.length > 0\n    const firstIndex = hasSlidesInView ? inViewList[0] : startIndex\n    const slideIndex = slideIndexCounter.clone().set(firstIndex)\n    const getNextIndex = (): number => slideIndex.add(direction).get()\n\n    slideIndex.set(getNextIndex())\n\n    while (slideIndex.get() !== firstIndex) {\n      const index = slideIndex.get()\n      const isInView = isSlideInView(index)\n\n      if (!isInView && hasSlidesInView) break\n      if (isInView) inViewList.push(index)\n\n      const nextIndex = getNextIndex()\n      slideIndex.set(nextIndex)\n\n      if (loop) continue\n\n      const isStart = !nextIndex\n      const isEnd = arrayIsLastIndex(snaps, nextIndex)\n      if (isStart && direction === -1) break\n      if (isEnd && direction === 1) break\n    }\n  }\n\n  function getSlidesInViewRange(): number[] {\n    const inViewList: number[] = []\n    const snap = scrollSnapList.slidesBySnap[indexCurrent.get()]\n    if (!snap) return inViewList\n    if (!snaps.length) return inViewList\n\n    const from = offsetlocation.get()\n    const to = target.get()\n    const startIndex = snap[Math.floor(snap.length / 2)]\n    const rangeStart = Math.max(from, to)\n    const rangeEnd = Math.min(from, to)\n    const isSlideInView = getIsSlideInView(rangeStart, rangeEnd)\n\n    if (isSlideInView(startIndex)) inViewList.push(startIndex)\n    collectSlidesInView(inViewList, startIndex, 1, isSlideInView)\n    collectSlidesInView(inViewList, startIndex, -1, isSlideInView)\n\n    return inViewList\n  }\n\n  function updateSlideVisibility(newTarget: number): void {\n    slidesInView = getSlidesInViewRange()\n    slidesLeftView = filterNotIncluded(slidesInViewPrevious, slidesInView)\n    slidesInViewPrevious = slidesInView\n    previousTarget = newTarget\n  }\n\n  function toggleGpuLayer(enable: boolean, slides: number[]): void {\n    slides.forEach((index) => {\n      const translate = slideTranslates[index]\n      const loopSlide = slideLooper.loopPoints[index]\n      const loopOffset = loop && loopSlide ? loopSlide.target() : 0\n      if (!loopOffset) translate.setIsScrolling(enable)\n    })\n  }\n\n  function optimize(settle?: boolean): void {\n    const newTarget = target.get()\n    if (!settle && newTarget === previousTarget) return\n\n    updateSlideVisibility(newTarget)\n\n    const event = eventHandler.createEvent('scrolloptimize', {\n      slidesInView,\n      slidesLeftView\n    })\n    const preventDefault = !event.emit()\n    if (preventDefault) return\n\n    toggleGpuLayer(true, slidesInView)\n    toggleGpuLayer(false, slidesLeftView)\n  }\n\n  const self: ScrollOptimizerType = {\n    optimize\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Animations, AnimationsType } from './Animations'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { NodeRectsType, NodeRectType } from './NodeHandler'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ResizeHandler, ResizeHandlerType } from './ResizeHandler'\nimport { ScrollAnimator } from './ScrollAnimator'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollSnapList, ScrollSnapListType } from './ScrollSnapList'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideFocus, SlideFocusType } from './SlideFocus'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesHandler, SlidesHandlerType } from './SlidesHandler'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { NumberStore, NumberStoreType } from './NumberStore'\nimport { NodeHandlerType } from './NodeHandler'\nimport { ScrollOptimizer, ScrollOptimizerType } from './ScrollOptimizer'\n\nexport type EngineType = {\n  isSsr: boolean\n  eventHandler: EventHandlerType\n  contentSize: number\n  axis: AxisType\n  animation: AnimationsType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  indexCurrent: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: NumberStoreType\n  offsetLocation: NumberStoreType\n  previousLocation: NumberStoreType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: NumberStoreType\n  translate: TranslateType\n  slideTranslates: TranslateType[]\n  resizeHandler: ResizeHandlerType\n  slidesHandler: SlidesHandlerType\n  nodeHandler: NodeHandlerType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  scrollOptimizer: ScrollOptimizerType\n  slideSizes: number[]\n  slideFocus: SlideFocusType\n  scrollSnapList: ScrollSnapListType\n  containerRect: NodeRectType\n  slideRects: NodeRectType[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  nodeHandler: NodeHandlerType,\n  eventHandler: EventHandlerType,\n  rects: NodeRectsType,\n  isSsr: boolean\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startSnap,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    inViewMargin,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    draggable,\n    resize,\n    slideChanges,\n    focus\n  } = options\n\n  // Measurements\n  const pixelTolerance = isSsr ? 0 : 2\n  const axis = Axis(scrollAxis, direction)\n  const { containerRect, slideRects } = rects\n  const viewSize = axis.getSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && !!containScroll\n  const readEdgeGap = loop || !!containScroll\n  const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n    nodeHandler\n  )\n  const slidesToScroll = SlidesToScroll(\n    axis,\n    viewSize,\n    groupSlides,\n    loop,\n    containerRect,\n    slideRects,\n    startGap,\n    endGap,\n    pixelTolerance\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slidesToScroll\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained, scrollContainLimit } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n    pixelTolerance\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const indexCurrent = Counter(arrayLastIndex(scrollSnaps), startSnap, loop)\n  const indexPrevious = indexCurrent.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Animation\n  const scrollAnimator = ScrollAnimator()\n  const animation = Animations(\n    () => scrollAnimator.update(engine),\n    (alpha: number) => scrollAnimator.render(engine, alpha)\n  )\n\n  // Shared\n  const friction = 0.68\n  const startLocation = scrollSnaps[indexCurrent.get()]\n  const location = NumberStore(startLocation)\n  const previousLocation = NumberStore(startLocation)\n  const offsetLocation = NumberStore(startLocation)\n  const target = NumberStore(startLocation)\n  const translate = Translate(axis, container)\n  const slideTranslates = slides.map((slide) => Translate(axis, slide))\n\n  const scrollProgress = ScrollProgress(limit)\n  const scrollBody = ScrollBody(\n    location,\n    offsetLocation,\n    previousLocation,\n    target,\n    duration,\n    friction\n  )\n  const scrollSnapList = ScrollSnapList(\n    containSnaps,\n    containScroll,\n    scrollSnaps,\n    scrollContainLimit,\n    slidesToScroll,\n    slideIndexes,\n    scrollProgress\n  )\n  const slideLooper = SlideLooper(\n    viewSize,\n    contentSize,\n    slideSizes,\n    slideSizesWithGaps,\n    snaps,\n    scrollSnaps,\n    offsetLocation,\n    slideTranslates\n  )\n  const scrollOptimizer = ScrollOptimizer(\n    viewSize,\n    contentSize,\n    slideSizesWithGaps,\n    snaps,\n    loop,\n    indexCurrent,\n    scrollSnapList,\n    offsetLocation,\n    target,\n    slideTranslates,\n    slideLooper,\n    eventHandler\n  )\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    indexCurrent,\n    indexPrevious,\n    scrollBody,\n    scrollTarget,\n    target,\n    eventHandler\n  )\n  const eventStore = EventStore()\n  const slidesInView = SlidesInView(\n    container,\n    slides,\n    eventHandler,\n    inViewThreshold,\n    inViewMargin\n  )\n  const slideFocus = SlideFocus(\n    axis,\n    focus,\n    root,\n    slides,\n    scrollSnapList,\n    scrollTo,\n    scrollBody,\n    eventStore,\n    eventHandler\n  )\n\n  // Engine\n  const engine: EngineType = {\n    eventHandler,\n    containerRect,\n    contentSize,\n    slideRects,\n    nodeHandler,\n    animation,\n    slideSizes,\n    isSsr,\n    axis,\n    dragHandler: DragHandler(\n      draggable,\n      axis,\n      root,\n      target,\n      DragTracker(axis),\n      location,\n      animation,\n      scrollTo,\n      scrollBody,\n      scrollTarget,\n      indexCurrent,\n      eventHandler,\n      percentOfView,\n      dragFree,\n      dragThreshold,\n      skipSnaps,\n      friction\n    ),\n    eventStore,\n    percentOfView,\n    indexCurrent,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(\n      resize,\n      container,\n      eventHandler,\n      slides,\n      axis,\n      nodeHandler\n    ),\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      offsetLocation,\n      target,\n      scrollBody,\n      percentOfView\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n      location,\n      offsetLocation,\n      previousLocation,\n      target\n    ]),\n    scrollProgress,\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper,\n    slideFocus,\n    slidesHandler: SlidesHandler(slideChanges, container, eventHandler),\n    slidesInView,\n    slideIndexes,\n    slidesToScroll,\n    slideTranslates,\n    scrollSnapList,\n    scrollOptimizer,\n    translate,\n    target\n  }\n\n  return engine\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { PointerEventType } from './DragTracker'\nimport { SelectEventType } from './ScrollTo'\nimport { ScrollEventType } from './ScrollAnimator'\nimport { ScrollOptimizeEventType } from './ScrollOptimizer'\nimport { SlidesInViewEventType } from './SlidesInView'\n\nexport type EmblaEventType = keyof EmblaEventListType\n\nexport type EmblaEventModelType<EventType extends keyof EmblaEventListType> = {\n  api: EmblaCarouselType\n  type: EmblaEventType\n  detail: EmblaEventListType[EventType]\n}\n\nexport type EmblaCreatedEventType = {\n  api: EmblaCarouselType\n  emit: () => boolean\n}\n\nexport type EmblaEventCallbackType<EventType extends keyof EmblaEventListType> =\n  (\n    api: EmblaCarouselType,\n    event: EmblaEventModelType<EventType>\n  ) => boolean | void\n\ntype EventStoreType = Partial<{\n  [EventType in keyof EmblaEventListType]: EmblaEventCallbackType<EventType>[]\n}>\n\nexport interface EmblaEventListType {\n  pointerdown: PointerEventType\n  pointermove: PointerEventType\n  pointerup: PointerEventType\n  slideschanged: MutationRecord[]\n  slidesinview: SlidesInViewEventType\n  scrolloptimize: ScrollOptimizeEventType\n  select: SelectEventType\n  scroll: ScrollEventType\n  settle: null\n  destroy: null\n  reinit: null\n  resize: ResizeObserverEntry[]\n  slidefocus: FocusEvent\n}\n\nexport type EventHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  clear: () => void\n  createEvent: <EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    detail: EmblaEventListType[EventType]\n  ) => EmblaCreatedEventType\n  on<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    callback: EmblaEventCallbackType<EventType>\n  ): EventHandlerType\n  off<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    callback: EmblaEventCallbackType<EventType>\n  ): EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  let eventStore: EventStoreType = {}\n  let api: EmblaCarouselType\n\n  function init(emblaApi: EmblaCarouselType): void {\n    api = emblaApi\n  }\n\n  function getStore<EventType extends keyof EmblaEventListType>(\n    type: EventType\n  ): EmblaEventCallbackType<EventType>[] {\n    return eventStore[type] || []\n  }\n\n  function setStore<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    update: (\n      handlers: EmblaEventCallbackType<EventType>[]\n    ) => EmblaEventCallbackType<EventType>[]\n  ): EventHandlerType {\n    eventStore = { ...eventStore, [type]: update(getStore(type)) }\n    return self\n  }\n\n  function createEventModel<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    detail: EmblaEventListType[EventType]\n  ): EmblaEventModelType<EventType> {\n    return { api, type, detail }\n  }\n\n  function createEvent<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    detail: EmblaEventListType[EventType]\n  ): EmblaCreatedEventType {\n    const event: EmblaCreatedEventType = {\n      api,\n      emit: () => emit(type, detail)\n    }\n    return event\n  }\n\n  function emit<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    detail: EmblaEventListType[EventType]\n  ): boolean {\n    const event = createEventModel(type, detail)\n    return getStore(type).every((handler) => handler(api, event) !== false)\n  }\n\n  function on<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    callback: EmblaEventCallbackType<EventType>\n  ): EventHandlerType {\n    setStore(type, (handlers) => {\n      return handlers.includes(callback) ? handlers : [...handlers, callback]\n    })\n    return self\n  }\n\n  function off<EventType extends keyof EmblaEventListType>(\n    type: EventType,\n    callback: EmblaEventCallbackType<EventType>\n  ): EventHandlerType {\n    setStore(type, (handlers) => {\n      return handlers.filter((handler) => handler !== callback)\n    })\n    return self\n  }\n\n  function clear(): void {\n    eventStore = {}\n  }\n\n  const self: EventHandlerType = {\n    init,\n    clear,\n    createEvent,\n    on,\n    off\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisDirectionOptionType, AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport {\n  SlidesInViewMarginOptionsType,\n  SlidesInViewThresholdOptionsType\n} from './SlidesInView'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  container: string | HTMLElement | null\n  slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null\n  containScroll: ScrollContainOptionType\n  direction: AxisDirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  dragThreshold: number\n  inViewThreshold: SlidesInViewThresholdOptionsType\n  inViewMargin: SlidesInViewMarginOptionsType\n  loop: boolean\n  skipSnaps: boolean\n  duration: number\n  startSnap: number\n  draggable: boolean\n  resize: boolean\n  focus: boolean\n  slideChanges: boolean\n  ssr: number[]\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: 'trimSnaps',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  inViewMargin: '0px',\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startSnap: 0,\n  active: true,\n  draggable: true,\n  resize: true,\n  focus: true,\n  slideChanges: true,\n  ssr: []\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { OptionsType } from './Options'\nimport { isString, WindowType } from './utils'\n\nexport type NodeRectType = {\n  top: number\n  right: number\n  bottom: number\n  left: number\n  width: number\n  height: number\n}\n\nexport type NodeRectsType = {\n  containerRect: NodeRectType\n  slideRects: NodeRectType[]\n}\n\ntype NodesType = {\n  root: HTMLElement\n  container: HTMLElement\n  slides: HTMLElement[]\n}\n\nexport type NodeHandlerType = {\n  ownerDocument: Document | null\n  ownerWindow: WindowType | null\n  getNodes: (options: OptionsType) => NodesType\n  getRect: (node: HTMLElement) => NodeRectType\n  getRects: (\n    container: HTMLElement,\n    slides: HTMLElement[],\n    fromCache?: boolean\n  ) => NodeRectsType\n}\n\nexport function NodeHandler(root: HTMLElement): NodeHandlerType {\n  const ownerDocument = root ? root.ownerDocument : null\n  const ownerWindow = ownerDocument\n    ? <WindowType>ownerDocument.defaultView\n    : null\n\n  let rects: NodeRectsType\n\n  function getRect(node: HTMLElement): NodeRectType {\n    const { offsetTop: top, offsetLeft: left, offsetWidth, offsetHeight } = node\n    const offset: NodeRectType = {\n      top,\n      right: left + offsetWidth,\n      bottom: top + offsetHeight,\n      left,\n      width: offsetWidth,\n      height: offsetHeight\n    }\n\n    return offset\n  }\n\n  function getRects(\n    container: HTMLElement,\n    slides: HTMLElement[],\n    fromCache?: boolean\n  ): NodeRectsType {\n    if (fromCache && rects) return rects\n\n    const containerStyle = root ? container.style : { transform: '' }\n    const previousTransform = containerStyle.transform\n    containerStyle.transform = 'none'\n\n    const containerRect = getRect(container)\n    const slideRects = slides.map(getRect)\n\n    containerStyle.transform = previousTransform\n    rects = { containerRect, slideRects }\n    return rects\n  }\n\n  function createSsrNode(\n    offsetLeft: number,\n    offsetTop: number,\n    offsetWidth: number,\n    offsetHeight: number\n  ): HTMLElement {\n    return <HTMLElement>{ offsetLeft, offsetTop, offsetWidth, offsetHeight }\n  }\n\n  function getBrowserNodes(options: OptionsType): NodesType {\n    const { container: userContainer, slides: userSlides } = options\n\n    const containerNode = isString(userContainer)\n      ? root.querySelector(userContainer)\n      : userContainer\n    const container = <HTMLElement>(containerNode || root.children[0])\n\n    const slideNodes = isString(userSlides)\n      ? container.querySelectorAll(userSlides)\n      : userSlides\n    const slides = <HTMLElement[]>Array.from(slideNodes || container.children)\n\n    return { root, container, slides }\n  }\n\n  function getSsrNodes(options: OptionsType): NodesType {\n    const rootSize = 100\n    const root = createSsrNode(0, 0, rootSize, rootSize)\n    const container = root\n    let startOffset = 0\n\n    const slides = options.ssr.map((size) => {\n      const slide = createSsrNode(startOffset, startOffset, size, size)\n      startOffset += size\n      return slide\n    })\n\n    return { root, container, slides }\n  }\n\n  function getNodes(options: OptionsType): NodesType {\n    return root ? getBrowserNodes(options) : getSsrNodes(options)\n  }\n\n  const self: NodeHandlerType = {\n    ownerDocument,\n    ownerWindow,\n    getNodes,\n    getRect,\n    getRects\n  }\n  return self\n}\n","import { NodeHandlerType } from './NodeHandler'\nimport { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsMergeDeep, WindowType } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  init: (ownerWindow: NodeHandlerType['ownerWindow']) => void\n  mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ) => TypeA\n  optionsAtMedia: <Type extends OptionsType>(options: Type) => Type\n  optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[]\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  let windowInstance: WindowType\n\n  function init(ownerWindow: NodeHandlerType['ownerWindow']): void {\n    if (ownerWindow) windowInstance = ownerWindow\n  }\n\n  function mergeOptions<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function optionsAtMedia<Type extends OptionsType>(options: Type): Type {\n    if (!windowInstance) return options\n\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => windowInstance.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce(\n        (mediaOptions, mediaOption) => mergeOptions(mediaOptions, mediaOption),\n        {}\n      )\n\n    return mergeOptions(options, matchedMediaOptions)\n  }\n\n  function optionsMediaQueries(optionsList: OptionsType[]): MediaQueryList[] {\n    if (!windowInstance) return []\n\n    return optionsList\n      .map((options) => objectKeys(options.breakpoints || {}))\n      .reduce((mediaQueries, mediaQuery) => mediaQueries.concat(mediaQuery), [])\n      .map(windowInstance.matchMedia)\n  }\n\n  const self: OptionsHandlerType = {\n    init,\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { OptionsHandlerType } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type PluginsHandlerType = {\n  init: (\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ) => EmblaPluginsType\n  destroy: () => void\n}\n\nexport function PluginsHandler(\n  optionsHandler: OptionsHandlerType\n): PluginsHandlerType {\n  let activePlugins: EmblaPluginType[] = []\n\n  function init(\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ): EmblaPluginsType {\n    activePlugins = plugins\n\n    return plugins.reduce((pluginList, plugin) => {\n      plugin.init(emblaApi, optionsHandler)\n      return { ...pluginList, [plugin.name]: plugin }\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { Axis, AxisType } from './Axis'\nimport { EngineType } from './Engine'\nimport { NodeHandlerType } from './NodeHandler'\nimport { OptionsType } from './Options'\nimport { OptionsHandlerType } from './OptionsHandler'\nimport { Translate } from './Translate'\nimport { mathSign } from './utils'\n\nexport type SsrHandlerType = {\n  getStyles: (containerSelector: string, slidesSelector?: string) => string\n}\n\nexport function SsrHandler(\n  container: HTMLElement,\n  axis: AxisType,\n  nodeHandler: NodeHandlerType,\n  options: OptionsType,\n  mergeOptions: OptionsHandlerType['mergeOptions'],\n  createEngine: (\n    options: OptionsType,\n    container: HTMLElement,\n    slides: HTMLElement[]\n  ) => EngineType\n): SsrHandlerType {\n  const translate = Translate(axis, container, '%')\n\n  function createStyles(\n    options: OptionsType,\n    containerSelector: string,\n    slidesSelector: string\n  ): string {\n    const { direction } = Axis(options.axis, options.direction)\n    const { slides, container } = nodeHandler.getNodes(options)\n    const { location, slideLooper, contentSize } = createEngine(\n      options,\n      container,\n      slides\n    )\n\n    const loopPoints = options.loop ? slideLooper.loopPoints : []\n    const containerLocation = direction(location)\n    const containerSsr = translate.get(containerLocation)\n    const baseStyles = `${containerSelector}{transform:${containerSsr};}`\n\n    const loopStyles = loopPoints.reduce((styles, loopPoint) => {\n      const { index } = loopPoint\n      const sign = mathSign(loopPoint.target())\n      const size = options.ssr[index]\n\n      if (!sign || !size) return styles\n      const slideLocation = direction((contentSize / size) * 100 * sign)\n      const slideSsr = translate.get(slideLocation)\n\n      return (\n        styles +\n        `${containerSelector} ${slidesSelector}:nth-child(${\n          index + 1\n        }){transform:${slideSsr};}`\n      )\n    }, '')\n\n    return baseStyles + loopStyles\n  }\n\n  function getStyles(\n    containerSelector: string,\n    slidesSelector: string = '> *'\n  ): string {\n    if (!options.ssr.length) return ''\n\n    const optionBreakpoints = options.breakpoints || {}\n    const baseStyles = createStyles(options, containerSelector, slidesSelector)\n    const mediaStyles = Object.keys(optionBreakpoints).reduce((styles, key) => {\n      const optionsAtMedia = mergeOptions(options, optionBreakpoints[key])\n      return (\n        styles +\n        `@media ${key}{${createStyles(\n          optionsAtMedia,\n          containerSelector,\n          slidesSelector\n        )}}`\n      )\n    }, '')\n\n    return baseStyles + mediaStyles\n  }\n\n  const self: SsrHandlerType = {\n    getStyles\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType, OptionsType } from './Options'\nimport { NodeHandler, NodeHandlerType } from './NodeHandler'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { SsrHandler, SsrHandlerType } from './SsrHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\nimport { ScrollToDirectionType } from './ScrollTo'\n\nexport type EmblaCarouselType = {\n  canGoToNext: () => boolean\n  canGoToPrev: () => boolean\n  goToNext: (instant?: boolean) => void\n  goToPrev: (instant?: boolean) => void\n  goTo: (\n    index: number,\n    instant?: boolean,\n    direction?: ScrollToDirectionType\n  ) => void\n  previousSnap: () => number\n  selectedSnap: () => number\n  rootNode: () => HTMLElement\n  containerNode: () => HTMLElement\n  slideNodes: () => HTMLElement[]\n  snapIndex: (offset: number) => number\n  snapList: () => number[]\n  createEvent: EventHandlerType['createEvent']\n  destroy: () => void\n  on: EventHandlerType['on']\n  off: EventHandlerType['off']\n  internalEngine: () => EngineType\n  cloneEngine: (userOptions?: EmblaOptionsType) => EngineType\n  plugins: () => EmblaPluginsType\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  ssrStyles: (container: string, slides?: string) => string\n  scrollProgress: () => number\n  slidesInView: () => number[]\n}\n\nfunction EmblaCarousel(\n  userRoot?: HTMLElement | null,\n  userOptions?: EmblaOptionsType | null,\n  userPlugins?: EmblaPluginType[] | null\n): EmblaCarouselType {\n  const isSsr = !userRoot\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler(optionsHandler)\n  const mediaHandlers = EventStore()\n  const eventHandler = EventHandler()\n  const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler\n  const { on, off, createEvent } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let nodeHandler: NodeHandlerType\n  let ssrHandler: SsrHandlerType\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions)\n  let options = mergeOptions(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType = {}\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function cloneEngine(userOptions?: EmblaOptionsType): EngineType {\n    const engineOptions = mergeOptions(options, userOptions)\n    return createEngine(engineOptions, container, slides, true)\n  }\n\n  function createEngine(\n    options: OptionsType,\n    container: HTMLElement,\n    slides: HTMLElement[],\n    useCachedRects?: boolean\n  ): EngineType {\n    const ssrOptions = isSsr ? { direction: 'ltr' } : {}\n    const engineOptions = mergeOptions(options, ssrOptions)\n    const rects = nodeHandler.getRects(container, slides, useCachedRects)\n    const engine = Engine(\n      root,\n      container,\n      slides,\n      engineOptions,\n      nodeHandler,\n      eventHandler,\n      rects,\n      isSsr\n    )\n\n    if (options.loop && !engine.slideLooper.canLoop()) {\n      const optionsWithNoLoop = mergeOptions(options, { loop: false })\n      return createEngine(optionsWithNoLoop, container, slides, true)\n    }\n\n    return engine\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    if (destroyed) return\n\n    nodeHandler = NodeHandler(<HTMLElement>userRoot)\n    const { ownerWindow } = nodeHandler\n\n    optionsHandler.init(ownerWindow)\n    optionsBase = mergeOptions(optionsBase, withOptions)\n    options = optionsAtMedia(optionsBase)\n    pluginList = withPlugins || pluginList\n\n    const nodes = nodeHandler.getNodes(options)\n    root = nodes.root\n    container = nodes.container\n    slides = nodes.slides\n    engine = createEngine(options, container, slides)\n\n    ssrHandler = SsrHandler(\n      container,\n      engine.axis,\n      nodeHandler,\n      optionsBase,\n      mergeOptions,\n      createEngine\n    )\n\n    optionsMediaQueries([\n      optionsBase,\n      ...pluginList.map(({ options }) => options)\n    ]).forEach((query) => mediaHandlers.add(query, 'change', reActivate))\n\n    if (!options.active) return\n\n    if (!isSsr && ownerWindow) {\n      engine.translate.to(engine.location)\n      engine.scrollOptimizer.optimize(true)\n      if (engine.options.loop) engine.slideLooper.loop()\n\n      engine.animation.init(ownerWindow)\n      engine.resizeHandler.init(ownerWindow)\n      engine.slidesInView.init(ownerWindow)\n      engine.slidesHandler.init(ownerWindow)\n      engine.slideFocus.init(ownerWindow)\n      engine.eventHandler.init(self)\n\n      if (container.offsetParent && slides.length) {\n        engine.dragHandler.init(ownerWindow)\n      }\n    }\n\n    pluginApis = pluginsHandler.init(self, pluginList)\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    const event = eventHandler.createEvent('reinit', null)\n    const startSnap = selectedSnap()\n    deActivate()\n    activate(mergeOptions({ startSnap }, withOptions), withPlugins)\n    event.emit()\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.destroy()\n    engine.resizeHandler.destroy()\n    engine.slidesHandler.destroy()\n    engine.slidesInView.destroy()\n    engine.animation.destroy()\n    pluginsHandler.destroy()\n    engine.eventStore.clear()\n    mediaHandlers.clear()\n    engine.translate.clear()\n    engine.slideTranslates.forEach((translate) => translate.clear())\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    if (isSsr) return\n\n    const event = eventHandler.createEvent('destroy', null)\n\n    destroyed = true\n    mediaHandlers.clear()\n    deActivate()\n    event.emit()\n    eventHandler.clear()\n  }\n\n  function goTo(\n    index: number,\n    instant?: boolean,\n    direction?: ScrollToDirectionType\n  ): void {\n    if (destroyed) return\n    if (isSsr) return\n    if (!options.active) return\n\n    engine.scrollBody\n      .useBaseFriction()\n      .useDuration(instant === true ? 0 : options.duration)\n    engine.scrollTo.index(index, direction)\n  }\n\n  function goToNext(instant?: boolean): void {\n    goTo(snapIndex(1), instant, -1)\n  }\n\n  function goToPrev(instant?: boolean): void {\n    goTo(snapIndex(-1), instant, 1)\n  }\n\n  function canGoToNext(): boolean {\n    return snapIndex(1) !== selectedSnap()\n  }\n\n  function canGoToPrev(): boolean {\n    return snapIndex(-1) !== selectedSnap()\n  }\n\n  function ssrStyles(container: string, slides?: string): string {\n    return isSsr ? ssrHandler.getStyles(container, slides) : ''\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.offsetLocation)\n  }\n\n  function snapIndex(offset: number): number {\n    return engine.indexCurrent.add(offset).get()\n  }\n\n  function snapList(): number[] {\n    return engine.scrollSnapList.progressBySnap\n  }\n\n  function selectedSnap(): number {\n    return snapIndex(0)\n  }\n\n  function previousSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function slidesInView(): number[] {\n    return engine.slidesInView.get()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canGoToNext,\n    canGoToPrev,\n    cloneEngine,\n    containerNode,\n    createEvent,\n    internalEngine,\n    destroy,\n    on,\n    off,\n    plugins,\n    previousSnap,\n    reInit,\n    rootNode,\n    goToNext,\n    goToPrev,\n    scrollProgress,\n    goTo,\n    selectedSnap,\n    slideNodes,\n    slidesInView,\n    snapIndex,\n    snapList,\n    ssrStyles\n  }\n\n  activate(userOptions || {}, userPlugins || [])\n  return self\n}\n\ndeclare namespace EmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nEmblaCarousel.globalOptions = undefined\n\nexport default EmblaCarousel\n"],"names":["mapStoreToNumber","callback","input","isNumber","get","subject","isString","isObject","Object","prototype","toString","call","mathAbs","Math","abs","mathSign","sign","deltaAbs","inputB","inputA","factorAbs","diff","roundToTwoDecimals","round","arrayKeys","array","objectKeys","map","Number","arrayLast","arrayLastIndex","max","length","arrayIsLastIndex","index","arrayFromRange","end","start","Array","from","_","object","keys","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","valueA","valueB","areObjects","isMouseEvent","evt","ownerWindow","MouseEvent","Alignment","align","viewSize","predefined","center","measure","self","EventStore","listeners","add","node","type","handler","options","passive","removeListener","addEventListener","removeEventListener","legacyMediaQueryList","addListener","push","clear","filter","remove","Animations","update","render","documentVisibleHandler","fixedTimeStep","windowInstance","lastTimeStamp","accumulatedTime","animationId","init","ownerDocument","document","hidden","reset","destroy","stop","animate","timeStamp","timeElapsed","alpha","requestAnimationFrame","cancelAnimationFrame","Axis","axis","contentDirection","isRightToLeft","isVertical","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","nativeScroll","getSize","nodeRect","height","width","direction","Limit","min","pastMinBound","pastMaxBound","pastAnyBound","clamp","removeOffset","ceil","Counter","loop","loopEnd","counter","normalize","set","clone","DragHandler","active","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","indexCurrent","eventHandler","percentOfView","dragFree","dragThreshold","skipSnaps","baseFriction","crossAxis","focusNodes","nonPassiveEvent","initEvents","mouseEvents","goToNextThreshold","snapForceBoost","mouse","touch","freeForceBoost","baseDuration","documentInstance","isMoving","startScroll","startCross","runTouchEvents","pointerIsDown","preventScroll","preventClick","isMouse","preventDefault","e","move","up","down","click","addMouseEvents","isFocusNode","nodeName","includes","forceBoost","boost","indexChanged","currentLocation","byDistance","baseForce","force","distance","allowedForce","next","byIndex","event","createEvent","emit","isMouseEvt","isNotLeftButton","button","buttons","pointerDown","useFriction","useDuration","readPoint","isTouchEvt","isPinching","touches","lastScroll","lastCross","diffScroll","diffCross","cancelable","pointerMove","rawForce","pointerUp","forceFactor","duration","friction","stopPropagation","DragTracker","logInterval","startEvent","lastEvent","readTime","evtAxis","property","coord","expired","diffDrag","diffTime","isFlick","PercentOfView","ResizeHandler","container","slides","nodeHandler","observeNodes","resizeObserver","containerSize","slideSizes","destroyed","readSize","getRect","ResizeObserver","onResize","observe","disconnect","entries","entry","isContainer","slideIndex","indexOf","lastSize","newSize","diffSize","api","reInit","ScrollAnimator","engine","dragHandler","scrollBounds","constrain","seek","translate","offsetLocation","previousLocation","scrollLooper","slideLooper","scrollOptimizer","isIdle","settled","isWithinBounds","shouldConstrain","isPointerDown","canSettle","isIdleAndCanSettle","isScrolling","isDragging","isSettled","optimize","interpolatedLocation","to","ScrollBody","scrollVelocity","scrollDirection","scrollDuration","scrollFriction","rawLocation","rawLocationPrevious","displacement","minus","isInstant","scrollDistance","velocity","useBaseDuration","useBaseFriction","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","frictionLimit","disabled","edge","diffToEdge","subtract","toggleActive","ScrollContain","contentSize","snapsAligned","containScroll","pixelTolerance","snapsBounded","getSnapsBounded","scrollContainLimit","getScrollContainLimit","snapsContained","getSnapsContained","usePixelTolerance","bound","snap","startSnap","endSnap","lastIndexOf","snapAligned","isFirst","isLast","scrollBound","parseFloat","toFixed","slice","ScrollLimit","scrollSnaps","ScrollLooper","loopEntities","jointSafety","shouldLoop","loopDistance","loopEntity","ScrollProgress","ScrollSnaps","alignment","containerRect","slideRects","slidesToScroll","groupSlides","alignments","measureSizes","snaps","measureUnaligned","measureAligned","rects","rect","g","ScrollSnapList","containSnaps","slideIndexes","scrollProgress","slidesBySnap","getSlidesBySnap","snapBySlide","getSnapsBySlide","progressBySnap","groupedSlideIndexes","doNotContain","group","groups","rangeEnd","slideGroup","snapIndex","ScrollTarget","targetVector","minDistance","distances","sort","a","b","getClosestSnap","result","displacementAbs","shortcut","smallestDisplacement","Infinity","targets","validTargets","t","diffToSnap","snapToClosest","plus","targetSnapDistance","isPastAnyBound","snapDistance","ScrollTo","indexPrevious","targetSnap","targetDisplacement","sourceSnap","hasIndexChanged","targetIndex","getDirection","SlideFocus","root","scrollSnapList","eventStore","focusListenerOptions","capture","lastTabPressTime","onKeyDown","slide","onFocus","nowTime","Date","getTime","code","NumberStore","initialValue","value","SlideLooper","slideSizesWithGaps","slideTranslates","roundingSafety","ascItems","descItems","reverse","loopPoints","startPoints","concat","endPoints","getRemainingGapAfterSlides","indexes","remainingGap","getSlidesThatFitGap","gap","slidesThatFit","getSlideBounds","offset","getLoopPoints","isEndEdge","slideBounds","initial","altered","boundEdge","loopPoint","slideLocation","canLoop","every","otherIndexes","i","shiftLocation","SlidesHandler","mutationObserver","MutationObserver","onSlidesChange","childList","mutations","mutation","SlidesInView","threshold","rootMargin","slidesInView","Set","intersectionObserver","IntersectionObserver","onIntersection","parentElement","slidesEnterView","slidesLeftView","isIntersecting","delete","SlideSizes","readEdgeGap","withEdgeGap","startGap","getStartGap","endGap","getEndGap","getSlideSizesWithGaps","slideRect","style","getComputedStyle","getPropertyValue","SlidesToScroll","groupByNumber","byNumber","groupSize","bySize","rectB","rectA","edgeA","edgeB","gapA","gapB","chunkSize","currentSize","previousSize","Translate","unit","getTranslate","x","y","lastTranslate","transform","setIsScrolling","newTarget","getAttribute","removeAttribute","ScrollOptimizer","offsetlocation","inViewThreshold","inViewOffsets","inViewBounds","createSlideBounds","slideIndexCounter","previousTarget","getSlidesInViewRange","slidesInViewPrevious","filterNotIncluded","source","exclusion","exclusionSet","item","has","createSlideBound","inViewOffset","assign","getIsSlideInView","rangeStart","some","collectSlidesInView","inViewList","startIndex","isSlideInView","hasSlidesInView","firstIndex","getNextIndex","isInView","nextIndex","isStart","isEnd","floor","updateSlideVisibility","toggleGpuLayer","enable","loopSlide","loopOffset","settle","Engine","isSsr","scrollAxis","inViewMargin","draggable","resize","slideChanges","focus","scrollAnimator","startLocation","slideFocus","resizeHandler","slidesHandler","EventHandler","emblaApi","getStore","setStore","createEventModel","detail","on","handlers","off","defaultOptions","breakpoints","ssr","NodeHandler","defaultView","offsetTop","top","offsetLeft","left","offsetWidth","offsetHeight","right","bottom","getRects","fromCache","containerStyle","previousTransform","createSsrNode","getBrowserNodes","userContainer","userSlides","containerNode","querySelector","children","slideNodes","querySelectorAll","getSsrNodes","rootSize","startOffset","size","getNodes","OptionsHandler","mergeOptions","optionsA","optionsB","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOptions","mediaOption","optionsMediaQueries","optionsList","mediaQueries","mediaQuery","PluginsHandler","optionsHandler","activePlugins","plugins","pluginList","plugin","name","SsrHandler","createEngine","createStyles","containerSelector","slidesSelector","containerLocation","containerSsr","baseStyles","loopStyles","styles","slideSsr","getStyles","optionBreakpoints","mediaStyles","EmblaCarousel","userRoot","userOptions","userPlugins","pluginsHandler","mediaHandlers","reActivate","ssrHandler","optionsBase","globalOptions","pluginApis","cloneEngine","engineOptions","useCachedRects","ssrOptions","optionsWithNoLoop","activate","withOptions","withPlugins","nodes","query","offsetParent","selectedSnap","deActivate","goTo","instant","goToNext","goToPrev","canGoToNext","canGoToPrev","ssrStyles","snapList","previousSnap","internalEngine","undefined"],"mappings":"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"}